(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{364:function(n,t,e){"use strict";e.r(t);var r=e(43),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("防抖和节流都是对多次频繁触发的处理，但是二者又有很大不同。")]),n._v(" "),e("p",[n._v("防抖是将多次触发情况变为一次触发，如下图蓝色的圆，准备从左边走到右边，而每次点击按钮都会让其重新回到左边。我们把左到右这段距离比作防抖限制的时间wait，那么每次触发，只要wait时间没有走完，则wait会重新开始计时。")]),n._v(" "),e("p",[e("img",{attrs:{src:"/imgs/debounce-ball.gif",alt:"debounce-ball.gif"}})]),n._v(" "),e("p",[n._v("节流则是将多次触发变为每隔一段时间触发一次。如下图红色的球，每次触发，只要还没走完wait时间，就不会从头开始走。")]),n._v(" "),e("p",[e("img",{attrs:{src:"/imgs/throttle-ball.gif",alt:"throttle-ball.gif"}})]),n._v(" "),e("p",[n._v("对于防抖函数而言，我们要设置一个timer，作为每次触发时的标杆。")]),n._v(" "),e("p",[n._v("如下面的流程图所示，当timer存在，说明上一次的wait时间没有走完，需要将timer清空，重新计时。如果timer不存在，就赋值一个timer开始计时，再判断函数是否要立即执行，是的话则执行代码，清空timer，不是的话即开始等待wait时间的结束。如果wait时间还未结束，函数又被触发了，则回到顶部的函数调用，再进行一轮判断。")]),n._v(" "),e("p",[e("img",{attrs:{src:"/imgs/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"防抖函数流程图"}})]),n._v(" "),e("p",[n._v("节流函数则在函数调用时判断是否走完了wait，是则执行，不是则继续等待。")]),n._v(" "),e("p",[e("img",{attrs:{src:"/imgs/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"节流函数流程图"}})]),n._v(" "),e("p",[n._v("本篇小文主要是帮自己梳理防抖和节流的不同，以及其中的实现思路。学习过程里一直参看 "),e("a",{attrs:{href:"https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96",target:"_blank",rel:"noopener noreferrer"}},[n._v("JS | 前端进阶之道"),e("OutboundLink")],1),n._v(" 。为了方便查阅，特将其中的防抖函数实现代码贴在下方。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 这个是用来获取当前时间戳的\nfunction now() {\n  return +new Date()\n}\n/**\n * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */\nfunction debounce (func, wait = 50, immediate = true) {\n  let timer, context, args\n\n  // 延迟执行函数\n  const later = () => setTimeout(() => {\n    // 延迟函数执行完毕，清空缓存的定时器序号\n    timer = null\n    // 延迟执行的情况下，函数会在延迟函数中执行\n    // 使用到之前缓存的参数和上下文\n    if (!immediate) {\n      func.apply(context, args)\n      context = args = null\n    }\n  }, wait)\n\n  // 这里返回的函数是每次实际调用的函数\n  return function(...params) {\n    // 如果没有创建延迟执行函数（later），就创建一个\n    if (!timer) {\n      timer = later()\n      // 如果是立即执行，调用函数\n      // 否则缓存参数和调用上下文\n      if (immediate) {\n        func.apply(this, params)\n      } else {\n        context = this\n        args = params\n      }\n    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个\n    // 这样做延迟函数会重新计时\n    } else {\n      clearTimeout(timer)\n      timer = later()\n    }\n  }\n}\n")])])]),e("p",[n._v("节流函数代码也是借鉴 "),e("a",{attrs:{href:"https://yuchengkai.cn/docs/frontend/#%E8%8A%82%E6%B5%81",target:"_blank",rel:"noopener noreferrer"}},[n._v("JS | 前端进阶之道"),e("OutboundLink")],1),n._v("，不过只取了部分以实现功能。这里对wait是否走完的判断依据为当前时间和上一次调用时间的差值：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function throttle (func, wait) {\n  var context, args\n  // 设置前一个函数被触发的时间戳\n  var previous = 0\n  // 返回给用户调用的回调\n  return function () {\n    var now = new Date().getTime()\n    // 首次进入\n    if (!previous) previous = now\n    // 准备context和args\n    context = this\n    args = arguments\n    // 计算剩余的时间时长\n    var remaining = wait - (now - previous)\n    // 如果 now 超过了previous + wait，可以执行函数\n    if (remaining <= 0) {\n      previous = now\n      timeout = null\n      result = func.apply(context, args)\n      context = args = null}\n  }\n}\n")])])]),e("p",[n._v("之前学习节流时，做过一个小练习，也贴"),e("a",{attrs:{href:"https://codepen.io/emmayxy/full/yLNRMRp",target:"_blank",rel:"noopener noreferrer"}},[n._v("在此"),e("OutboundLink")],1),n._v("，若有兴趣，可以看看效果，持续点击+按钮即可。")])])}),[],!1,null,null,null);t.default=a.exports}}]);